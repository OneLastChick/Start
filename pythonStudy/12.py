#coding=utf-8
import gmpy2
from Crypto.Util.number import *
from tqdm import tqdm 
from concurrent.futures import ThreadPoolExecutor
    # 执行任务

# 这些是您已经知道的数据
n = 849336070198288390697159953604631041220531450880470003711321629465667768166077048590424732899514364597846142552081203831820596307184634439370123843265553671296354569591313774601258300899064474499017739275029610061380878161903116951946992069179304873266107100260870067797885272618748439444942390788455561389992476954406519087651100823075474150373957306383931601466881212592340354743065590802393100489218225284001953152595652114101049569810322673437219068071706181
c = 475741333141462757793881409282042217780692822052921217109424580443961237213381397447967811064345794244140274226031155083573580253391162968191300055719645090150394862060018303286192874085824967930693339642931080748767098816986080760657519291597366738870604294584976443787088323260113027747748260843701704597633970477059337618053974397658302077784506519038970011113666127751403891194031794068761813239342821261561306173064983070348184193265245027101712278063481132
hint1 = 120449440767072697692260526356768867151900797126866831962791582051722337834272496306040266392970857331443304945208043184974545839559083122152617535911700506616166234686349718789435466632452850231215967104104770623313348017849390029462693490781093952017443419873930723022847350362617422002838363647138140636861490542645588949857984248849324823462820575382524407326817182105211699926409186025005941617152072902727772634106152751858688419401154647213576944110099017753007386576276467024773005501433764060204637098287585062517227
hint2 = 20123186615679024205160605414234626566940942287910540678511563813002058725261626970004390762737408611735274965746829224244760054762831463829713823500602928257527595393610311542872013222422020945489825869737846938176390076259343229285727420242889269920565106368211349295222840180017916815800882184668840349822489009787262028519306119958717340152473200709304316051437640034077762077781860527356550965692103019204774309986078200912115698461103576425065329034645281597238739283797192359674088774251544692915517594139364709373629993514517404908231479852585511023986128931947273667149434470373164739539923707937751872215328760626377887366588333891410906511768035556207011345565579236536614992098104628147107897765974286387409682540078853001677594466217359512230929931355828498790650224088975447549691521080237557141847105631941432185671451914903287337815695714546511291716157656308619635104453264901565276978649133910663686114829218784906187609939625410052112644023811106676834624862666199194953248963421491515648039870453068481034976685574679160249165304414547240720766815503613716692218871278204289618047380887014075354777551118617846690692758807745693804072169627063981

# mod = myfunction(n)
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm

# 定义一个函数，用于处理单个任务
def process_task(i):
    j = 0
    output = 0
    for _ in range(chunk_size):
        output += (i+j)*6 + 1
        j += i
    return output

# 定义任务的数量和每个线程处理的块大小
num = 100000
chunk_size = 10000

# 创建一个ThreadPoolExecutor来并行执行任务
with ThreadPoolExecutor(max_workers=4) as executor:  # 可根据需要设置最大线程数
    results = []

    for i in tqdm(range(0, num, chunk_size)):
        chunk_end = min(i + chunk_size, num)
        
        # 提交任务给线程池
        for j in range(i, chunk_end):
            results.append(executor.submit(process_task, j))

    # 等待所有任务完成并获取结果
    total_output = sum(result.result() for result in results)

mod = sum(result.result() for result in results)

print("Total output:", total_output)
print("mod:", mod)

# p % 2^400 - 1 = gmpy2.invert(3n+1, mod) * hint2 % mod
k = gmpy2.invert(3*n+1, mod) * hint2 % mod

# n = p * q * r
# R = bytes_to_long(str(r).encode())
# hint1 = R * r

# n % R == q % R * r % R
# n % R == (n // R) % R * r % R
# r == gmpy2.invert((n // R) % R, R) * (n % R) % R

chunk_size = 10000  # 调整为合适的大小
for i in tqdm(range(0, 256, chunk_size)):
    for j in range(i, min(i + chunk_size, 256)):
        R = hint1 + j * mod # 尝试不同的R值
        r = gmpy2.invert((n // R) % R, R) * (n % R) % R # 求解r
        if n % r == 0: # 检查r是否是n的因子
            print("R =", R)
            print("r =", r)
            break
# n = p * q * r
# phi(n) = (p-1)*(q-1)*(r-1)
# e*d == 1 (mod phi(n))
# c == m^e (mod n)
# m == c^d (mod n)

pq, rem = divmod(n, r)
assert rem == 0 # 检查pq是否是整数

# pq == p*q
# pq + 1 - k == p + q - ((p-1)*(q-1)+1) % 2^400
# pq + 1 - k == p + q - phi(pq) % 2^400

A = -1 # p的系数
B = pq + 1 - k # 常数项
C = pq # q的系数

D = B**2 - 4*A*C # 二次方程的判别式

assert D > 0 # 检查D是否为正

sD = gmpy2.iroot(D, 2)[0] # D的平方根

p = (-B + sD) // (2 * A) # 二次方程的一个根
q = (-B - sD) // (2 * A) # 二次方程的另一个根

assert n == p*q*r # 检查n是否是p, q, r的乘积

phi = (p-1)*(q-1)*(r-1) # 欧拉函数
e = 65537 # 公钥指数
d = gmpy2.invert(e, phi) # 私钥指数
m = pow(c, d, n) # 解密密文
print(long_to_bytes(m)) # 将明文转换成字节
